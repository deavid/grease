#############################################################################
#
# Copyright (c) 2010 by Casey Duncan and contributors
# All Rights Reserved.
#
# This software is subject to the provisions of the MIT License
# A copy of the license should accompany this distribution.
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#
#############################################################################
"""
**Grease collision detection systems**

Grease uses two-phase broad and narrow collision detection. *Broad-phase*
collision systems are used to efficiently identify pairs that may be colliding
without resorting to a brute-force check of all possible pairs. *Narrow-phase*
collision systems use the pairs generated by the broad-phase and perform more
precise collision tests to determine if a collision has actually occurred. The
narrow-phase system also calculates more details about each collision,
including collision point and normal vector for use in collision response.

A typical collision detection system consists of a narrow-phase system that
contains a broad-phased system. The narrow-phase system is usually the only

one that the application directly interacts with, though the application is
free to use the broad-phased system directly if desired. This could be
useful in cases where speed, rather than precision is paramount.

The narrow-phase system can be assigned handler objects to run after
collision detection. These can perform tasks like handling collision response
or dispatching collision events to application handlers.

Note that broad-phase systems can return false positives, though they should
never return false negatives. Do not assume that all pairs returned by a
broad-phase system are actually in collision.
"""

__version__ = '$Id$'

from grease.geometry import Vec2d
from bisect import bisect_right

import time, math

cdef extern from "unistd.h":
    long int sysconf(int)
    int _SC_CLK_TCK
    
cdef long int ticks_per_sec
ticks_per_sec = sysconf(_SC_CLK_TCK)

ctypedef struct tms:
   int tms_utime 
   int tms_stime 
   int tms_cutime 
   int tms_cstime 
    
cdef extern from "time.h":
    int clock ()
    int CLOCKS_PER_SEC
    int times (tms* )

cdef float MIN_TIME_DELTA = 50

cdef double curr_time1():
    cdef double ticks
    cdef tms time1

    ticks = times(&time1)
    #ticks = time1.tms_utime 
    ticks /= ticks_per_sec
    return ticks * 1000.0
    
cdef double curr_time():
    cdef double ticks
    ticks = time.time()
    return ticks * 1000.0

class Pair(tuple):
    """Pair of entities in collision. This is an ordered sequence of two
    entities, that compares and hashes unordered.
    
    Also stores additional collision point and normal vectors
    for each entity.

    Sets of ``Pair`` objects are exposed in the ``collision_pairs``
    attribute of collision systems to indicate the entity pairs in
    collision.
    """
    info = None
    """A sequence of (entity, collision point, collision normal)
    for each entity in the pair
    """

    def __new__(cls, entity1, entity2, point=None, normal=None):
        pair = tuple.__new__(cls, (entity1, entity2))
        return pair
    
    def __hash__(self):
        return hash(self[0]) ^ hash(self[1])
    
    def __eq__(self, other):
        other = tuple(other)
        return tuple(self) == other or (self[1], self[0]) == other
    
    def __repr__(self):
        return '%s%r' % (self.__class__.__name__, tuple(self))
    
    def set_point_normal(self, point0, normal0, point1, normal1):
        """Set the collision point and normal for both entities"""
        self.info = (
            (self[0], point0, normal0),
            (self[1], point1, normal1),
        )


cdef class BroadSweepAndPrune:
    """2D Broad-phase sweep and prune bounding box collision detector

    This algorithm is efficient for collision detection between many
    moving bodies. It has linear algorithmic complexity and takes
    advantage of temporal coherence between frames. It also does
    not suffer from bad worst-case performance (like RDC can). 
    Unlike spacial hashing, it does not need to be optimized for 
    specific space and body sizes.

    Other algorithms may be more efficient for collision detection with
    stationary bodies, bodies that are always evenly distributed, or ad-hoc
    queries.

    :param collision_component: Name of the collision component used by this
        system, defaults to 'collision'. This component supplies each
        entities' aabb and collision masks.
    :type collision_component: str
    """

    cdef object _collision_component
    cdef object _by_x
    cdef object _by_y
    cdef object _collision_pairs
    
    cdef object world
    cdef float minx
    cdef float maxx
    cdef float miny
    cdef float maxy
    cdef float totalarea
    cdef float usedarea
    cdef int resolution
    cdef int maxresolution
    cdef int stepn
    cdef float lastdt
    
    
    def get_collision_component(self):
        return self._collision_component
        
    def set_collision_component(self,value):
        self._collision_component = value
        
    collision_component = property(get_collision_component,set_collision_component)
    """Name of world's collision component used by this system"""

    cdef object LEFT_ATTR
    cdef object RIGHT_ATTR 
    cdef object TOP_ATTR 
    cdef object BOTTOM_ATTR
    
    def __cinit__(self, collision_component='collision'):
        self.RIGHT_ATTR = "right"
        self.TOP_ATTR = "top"
        self.LEFT_ATTR = "left"
        self.BOTTOM_ATTR = "bottom"
        self._by_x = None
        self._by_y = None
        self.stepn = 0
        self._collision_pairs = None
        self.maxresolution = 5
        self.resolution = self.maxresolution
     
    def __init__(self, collision_component='collision'):
        self._collision_component = collision_component
    
    def set_world(self, world):
        """Bind the system to a world"""
        self.world = world
        
    cpdef step(self, dt):
        """Update the system for this time step, updates and sorts the 
        axis arrays.
        """
        cdef double t1
        cdef double t2
        cdef double tdelta
        t1 = curr_time()
        self.stepn +=1
        self.lastdt = dt
        #if self.stepn % 10 == 0:
        #    print "dt: %.2fms (%.1ffps)" % (dt * 1000.0, 1.0/dt)
        #self.update_hash_ranges(component.itervalues())
        self._collision_pairs = None
        t2 = curr_time()
        tdelta = t2 - t1
        if tdelta > MIN_TIME_DELTA: 
            print "Collision-broad-step, tdelta: %.3fms (dt was %.3fms)" % (tdelta, dt*1000.0)
        return
        
        cdef object component = getattr(self.world.components, self.collision_component)
        cdef object LEFT = self.LEFT_ATTR
        cdef object RIGHT = self.RIGHT_ATTR
        cdef object TOP = self.TOP_ATTR
        cdef object BOTTOM = self.BOTTOM_ATTR
        if self._by_x is None:
            # Build axis lists from scratch
            # Note we cache the box positions here
            # so that we can perform hit tests efficiently
            # it also isolates us from changes made to the 
            # box positions after we run
            by_x = self._by_x = []
            append_x = by_x.append
            by_y = self._by_y = []
            append_y = by_y.append
            for data in component.itervalues():
                append_x([data.aabb.left, LEFT, data])
                append_x([data.aabb.right, RIGHT, data])
                append_y([data.aabb.bottom, BOTTOM, data])
                append_y([data.aabb.top, TOP, data])
        else:
            by_x = self._by_x
            by_y = self._by_y
            removed = []
            for entry in by_x:
                entry[0] = getattr(entry[2].aabb, entry[1])
            for entry in by_y:
                entry[0] = getattr(entry[2].aabb, entry[1])
            # Removing entities is inefficient, but expected to be rare
            if component.deleted_entities:
                deleted_entities = component.deleted_entities
                deleted_x = []
                deleted_y = []
                for i, (_, _, data) in enumerate(by_x):
                    if data.entity in deleted_entities:
                        deleted_x.append(i)
                deleted_x.reverse()
                for i in deleted_x:
                    del by_x[i]
                for i, (_, _, data) in enumerate(by_y):
                    if data.entity in deleted_entities:
                        deleted_y.append(i)
                deleted_y.reverse()
                for i in deleted_y:
                    del by_y[i]
            # Tack on new entities
            for entity in component.new_entities:
                data = component[entity]
                by_x.append([data.aabb.left, LEFT, data])
                by_x.append([data.aabb.right, RIGHT, data])
                by_y.append([data.aabb.bottom, BOTTOM, data])
                by_y.append([data.aabb.top, TOP, data])
                
        # Tim-sort is highly efficient with mostly sorted lists.
        # Because positions tend to change little each frame
        # we take advantage of this here. Obviously things are
        # less efficient with very fast moving, or teleporting entities
        by_x.sort()
        by_y.sort()
        self.minx = by_x[0][0]
        self.maxx = by_x[-1][0]
        self.miny = by_y[0][0]
        self.maxy = by_y[-1][0]
        
        self._collision_pairs = None
        
        t2 = curr_time()
        tdelta = t2 - t1
        if tdelta > MIN_TIME_DELTA: 
            print "Collision-broad-step, tdelta: %.3fms (dt was %.3fms)" % (tdelta, dt*1000.0)
            #print (minx, maxx), (miny,maxy)
        
    
    @property
    def collision_pairs(self):
        cdef double t1
        cdef double t2
        cdef double tdelta
        if self._collision_pairs is None:
            t1 = curr_time()
            
            self._c_collision_pairs()
            
            t2 = curr_time()
            tdelta = t2 - t1
            if tdelta > MIN_TIME_DELTA: 
                print "Collision-broad-pairs, tdelta: %.3fms" % (tdelta)
                
        ret = self._collision_pairs
        return ret
    
    cdef float getfloatkx(self, x):
        cdef float kx
        kx = (x - self.minx) * self.resolution / (self.maxx-self.minx)
        return kx
        
    cdef float getfloatky(self, y):
        cdef float ky
        ky = (y - self.miny) * self.resolution / (self.maxy-self.miny)
        return ky
    
    cdef float getinvfloatkx(self, kx):
        cdef float x
        x = self.minx + kx * (self.maxx-self.minx) / self.resolution
        return x
        
    cdef float getinvfloatky(self, ky):
        cdef float y
        y = self.miny + ky * (self.maxy-self.miny) / self.resolution
        return y
    
    cdef int getkx(self, x):
        return round(self.getfloatkx(x))
        
    cdef int getky(self, y):
        return round(self.getfloatky(y))
        
    cdef object update_partial_pairs(self,oxy,pidx):
        add_pair = self._collision_pairs.add
        cdef unsigned int mask1
        cdef unsigned int mask2
        cdef int added = 0
        cdef int viewed = 0
        
        for i in range(len(oxy)-1):
            d1 = oxy[i].entity
            for j in range(i+1,len(oxy)):
                d2 = oxy[j].entity
                mask1 = (d1.collision.from_mask & d2.collision.into_mask)
                mask2 = (d2.collision.from_mask & d1.collision.into_mask)
                viewed += 1
                if (mask1 | mask2) == 0: continue
                if d1.entity_id not in pidx:
                    pidx[d1.entity_id] = set([])
                if d2.entity_id not in pidx:
                    pidx[d2.entity_id] = set([])
                if d2.entity_id in pidx[d1.entity_id]: continue
                if d1.entity_id in pidx[d2.entity_id]: continue
                pidx[d1.entity_id].add(d2.entity_id)
                #pidx[d2.entity_id].add(d1.entity_id)
                pair = Pair(d1, d2)
                add_pair( pair )
                added += 1
        return added, viewed
                        
    cdef compute_hash_index(self, iterator, newrange):
        cdef float px
        cdef float py
        cdef float kpx
        cdef float kpy
        cdef float kx1
        cdef float ky1
        cdef float distance
        
        objk = {}
        if newrange is None:
            self.minx = 999
            self.maxx = -999
            self.miny = 999
            self.maxy = -999
            self.totalarea = 0
            self.usedarea = 0
            for data in iterator:
                kx = [ data.aabb.left, data.aabb.right ]
                ky = [ data.aabb.bottom, data.aabb.top ]
                if kx[0] < self.minx: self.minx = kx[0]
                if kx[1] > self.maxx: self.maxx = kx[1]
                if ky[0] < self.miny: self.miny = ky[0]
                if ky[1] > self.maxy: self.maxy = ky[1]
        else:
            self.minx = newrange[0]
            self.maxx = newrange[1]
            self.miny = newrange[2]
            self.maxy = newrange[3]
            self.usedarea = 0
        createdrange = (self.minx, self.maxx, self.miny, self.maxy)
        self.totalarea = (self.maxx - self.minx) * (self.maxy - self.miny)
        assert(self.totalarea > 0)
        #shape_radius = self.resolution * 0.7071
        added = 0
        for data in iterator:
            kx = [ data.aabb.left, data.aabb.right ]
            ky = [ data.aabb.bottom, data.aabb.top ]
            if kx[0] < self.minx: kx[0] = self.minx
            if kx[1] < self.minx: kx[1] = self.minx
            if kx[0] > self.maxx: kx[0] = self.maxx
            if kx[1] > self.maxx: kx[1] = self.maxx
            if ky[0] < self.miny: ky[0] = self.miny
            if ky[1] < self.miny: ky[1] = self.miny
            if ky[0] > self.maxy: ky[0] = self.maxy
            if ky[1] > self.maxy: ky[1] = self.maxy
            area = (kx[1] - kx[0]) * (ky[1] - ky[0])
            try:
                assert(area >= 0)
            except AssertionError:
                print "AssertionError: (%.5f - %.5f) * (%.5f - %.5f) = %.5f" % (kx[1],kx[0],ky[1],ky[0],area)
                continue
            if area == 0: continue
            self.usedarea += area
            
            kxp = [ self.getkx(x) for x in kx ]
            kyp = [ self.getky(y) for y in ky ]
            pos = None
            """try:
                px,py = data.entity.position.position
                pos = (px,py)
            except Exception:
                pos = None
            """    
            for x in range(kxp[0], kxp[1] + 1):
                if x not in objk:
                    objk[x] = {}
                validy = []
                for y in range(kyp[0], kyp[1] + 1):
                    if y not in objk[x]:
                        objk[x][y] = []
                    objk[x][y].append(data)
                    added += 1
        #if self.stepn % 30 == 0:
        #    print "Added:", added
        return objk, createdrange, added


    # ********** MAIN COLLISION (RECURSIVE) FUNCTION **************
    cdef object _c_update_pairs(self,iterator, pidx, depth = 0, newrange = None, pdict = None):
        cdef int forbid_zoom_in 
        cdef int forbid_zoom_in_msg
        viewed = 0
        added = 0
        prevused = self.usedarea
        objk, createdrange, objadded = self.compute_hash_index(iterator, newrange)
        if depth == 0: pdict = {"maxdepth":0,"objadded":0}
        if depth > pdict["maxdepth"]: pdict["maxdepth"] = depth
        pdict["objadded"] += objadded
        used = self.usedarea
        total = self.totalarea
        resolution = self.resolution
        
        if used > total and depth > 2 :
            forbid_zoom_in = True
        else:
            forbid_zoom_in = False
        forbid_zoom_in_msg = False
        if not prevused: prevused = used * 2
        for x, ox in objk.iteritems():
            for y, oxy in ox.iteritems():
                #if used < total and used < prevused and depth == 0 and len(oxy) >= 4 + depth:
                nsize = len(oxy)
                if nsize < 2: continue
                zoom_in = False
                if nsize >= 3 + depth: zoom_in = True
            
                if zoom_in and forbid_zoom_in:
                    forbid_zoom_in_msg = True
                if zoom_in and not forbid_zoom_in:
                    self.minx, self.maxx, self.miny, self.maxy = createdrange
                    newrange1 = (self.getinvfloatkx(x-0.5), self.getinvfloatkx(x+0.5), self.getinvfloatky(y-0.5), self.getinvfloatky(y+0.5))
                    #print "Old range: %.5f, %.5f, %.5f, %.5f" % (createdrange)
                    #print "Calculated range (%d,%d):" % (x,y) +  " %.5f, %.5f, %.5f, %.5f" % (newrange1)
                
                    self.resolution = 2
                    a,v = self._c_update_pairs(oxy,pidx, depth + 1, newrange1, pdict)
                    added += a
                    viewed+= v
                    self.resolution = resolution
                else:
                    if nsize > 2:
                        if nsize not in pdict: pdict[nsize] = 0
                        pdict[nsize]+=1
                    a,v = self.update_partial_pairs(oxy,pidx)
                    added+=a
                    viewed+=v
        #if depth == 0:
        #    print ", ".join(["%s:%d"% (k,v) for k,v in sorted(pdict.iteritems())]), "Add", added, "View +%d" %( viewed - added)
        #else:
        #    #if forbid_zoom_in_msg:    
        #    #    print "Avoiding zooming to depth %d. Area full." % (depth+1)

        #if self.stepn % 5 == 0 and depth == 0:
        #    print resolution, depth, viewed, "%d / %d" % (used, total)
        return added, viewed
        
        
        
    cdef int _c_collision_pairs(self) except -1:
        """Set of candidate collision pairs for this timestep"""
        pidx = {}
        self.usedarea = 0
        cdef object component = getattr(self.world.components, self.collision_component)
        self.resolution = self.maxresolution
        self._collision_pairs = set()
        self._c_update_pairs(list(component.itervalues()), pidx)
        return 0
            
        LEFT = self.LEFT_ATTR
        RIGHT = self.RIGHT_ATTR
        TOP = self.TOP_ATTR
        BOTTOM = self.BOTTOM_ATTR
        # Build candidates overlapping along the x-axis
        component = getattr(self.world.components, self.collision_component)
        xoverlaps = set()
        add_xoverlap = xoverlaps.add
        discard_xoverlap = xoverlaps.discard
        open = {}
        for _, side, data in self._by_x:
            if side is LEFT:
                for open_entity, (from_mask, into_mask) in open.iteritems():
                    if data.from_mask & into_mask or from_mask & data.into_mask:
                        add_xoverlap(Pair(data.entity, open_entity))
                open[data.entity] = (data.from_mask, data.into_mask)
            elif side is RIGHT:
                del open[data.entity]

        if len(xoverlaps) <= 10 and len(xoverlaps)*4 < len(self._by_y):
            # few candidates were found, so just scan the x overlap candidates
            # along y. This requires an additional sort, but it should
            # be cheaper than scanning everyone and its simpler
            # than a separate brute-force check
            entities = set([entity for entity, _ in xoverlaps] 
                + [entity for _, entity in xoverlaps])
            by_y = []
            for entity in entities:
                data = component[entity]
                # We can use tuples here, which are cheaper to create
                by_y.append((data.aabb.bottom, BOTTOM, data))
                by_y.append((data.aabb.top, TOP, data))
            by_y.sort()
        else:
            by_y = self._by_y

        # Now check the candidates along the y-axis
        open = set()
        add_open = open.add
        discard_open = open.discard
        self._collision_pairs = set()
        add_pair = self._collision_pairs.add
        for _, side, data in by_y:
            if side is BOTTOM:
                for open_entity in open:
                    pair = Pair(data.entity, open_entity)
                    if pair in xoverlaps:
                        discard_xoverlap(pair)
                        add_pair(pair)
                        if not xoverlaps:
                            # No more candidates, bail
                            return 1
                add_open(data.entity)
            elif side is TOP:
                discard_open(data.entity)

    
    def query_point(self, x_or_point, y=None, from_mask=0xffffffff):
        """Hit test at the point specified. 

        :param x_or_point: x coordinate (float) or sequence of (x, y) floats.

        :param y: y coordinate (float) if x is not a sequence

        :param from_mask: Bit mask used to filter query results. This value
            is bit ANDed with candidate entities' ``collision.into_mask``.
            If the result is non-zero, then it is considered a hit. By
            default all entities colliding with the input point are
            returned.

        :return: A set of entities where the point is inside their bounding
            boxes as of the last time step.
        """
        if self._by_x is None:
            # Axis arrays not ready
            return set()
        if y is None:
            x, y = x_or_point
        else:
            x = x_or_point
        LEFT = self.LEFT_ATTR
        RIGHT = self.RIGHT_ATTR
        TOP = self.TOP_ATTR
        BOTTOM = self.BOTTOM_ATTR
        x_index = bisect_right(self._by_x, [x])
        x_hits = set()
        add_x_hit = x_hits.add
        discard_x_hit = x_hits.discard
        if x_index <= len(self._by_x) // 2:
            # closer to the left, scan from left to right
            while (x == self._by_x[x_index][0] 
                and self._by_x[x_index][1] is LEFT 
                and x_index < len(self._by_x)):
                # Ensure we hit on exact left edge matches
                x_index += 1
            for _, side, data in self._by_x[:x_index]:
                if side is LEFT and from_mask & data.into_mask:
                    add_x_hit(data.entity)
                else:
                    discard_x_hit(data.entity)
        else:
            # closer to the right
            for _, side, data in reversed(self._by_x[x_index:]):
                if side is RIGHT and from_mask & data.into_mask:
                    add_x_hit(data.entity)
                else:
                    discard_x_hit(data.entity)
        if not x_hits:
            return x_hits

        y_index = bisect_right(self._by_y, [y])
        y_hits = set()
        add_y_hit = y_hits.add
        discard_y_hit = y_hits.discard
        if y_index <= len(self._by_y) // 2:
            # closer to the bottom
            while (y == self._by_y[y_index][0] 
                and self._by_y[y_index][1] is BOTTOM 
                and y_index < len(self._by_y)):
                # Ensure we hit on exact bottom edge matches
                y_index += 1
            for _, side, data in self._by_y[:y_index]:
                if side is BOTTOM:
                    add_y_hit(data.entity)
                else:
                    discard_y_hit(data.entity)
        else:
            # closer to the top
            for _, side, data in reversed(self._by_y[y_index:]):
                if side is TOP:
                    add_y_hit(data.entity)
                else:
                    discard_y_hit(data.entity)
        if y_hits:
            return x_hits & y_hits
        else:
            return y_hits


class Circular(object):
    """Basic narrow-phase collision detector which treats all entities as
    circles with their radius defined in the collision component.

    :param handlers: A sequence of collision handler functions that are invoked
        after collision detection.
    :type handlers: sequence of functions
    
    :param collision_component: Name of collision component for this system,
        defaults to 'collision'. This supplies each entity's collision
        radius and masks.
    :type collision_component: str

    :param position_component: Name of position component for this system,
        defaults to 'position'. This supplies each entity's position.
    :type position_component: str

    :param update_aabbs: If True (the default), then the entities'
        `collision.aabb` fields will be updated using their position
        and collision radius before invoking the broad phase system. 
        Set this False if another system updates the aabbs.
    :type update_aabbs: bool

    :param broad_phase: A broad-phase collision system to use as a source
        for collision pairs. If not specified, a :class:`BroadSweepAndPrune`
        system will be created automatically.
    """
    world = None
    """|World| object this system belongs to"""

    position_component = None
    """Name of world's position component used by this system"""

    collision_component = None
    """Name of world's collision component used by this system"""

    update_aabbs = True
    """Flag to indicate whether the system updates the entities' `collision.aabb`
    field before invoking the broad phase collision system
    """
    
    handlers = None
    """A sequence of collision handler functions invoke after collision
    detection
    """

    broad_phase = None
    """Broad phase collision system used as a source for collision pairs"""

    def __init__(self, handlers=(), position_component='position', 
        collision_component='collision', update_aabbs=True, broad_phase=None):
        self.handlers = tuple(handlers)
        if broad_phase is None:
            broad_phase = BroadSweepAndPrune(collision_component)
        self.collision_component = collision_component
        self.position_component = position_component
        self.update_aabbs = bool(update_aabbs)
        self.broad_phase = broad_phase
        self._collision_pairs = None
    
    def set_world(self, world):
        """Bind the system to a world"""
        self.world = world
        self.broad_phase.set_world(world)
        for handler in self.handlers:
            if hasattr(handler, 'set_world'):
                handler.set_world(world)
    
    def step(self, dt):
        """Update the collision system for this time step and invoke
        the handlers
        """
        t1 = curr_time()
        
        if self.update_aabbs:
            for position, collision in self.world.components.join(
                self.position_component, self.collision_component):
                aabb = collision.aabb
                x, y = position.position
                radius = collision.radius
                aabb.left = x - radius
                aabb.right = x + radius
                aabb.bottom = y - radius
                aabb.top = y + radius
                
        t2 = curr_time()
        tdelta = t2 - t1
        if tdelta > MIN_TIME_DELTA: 
            print "Collision-circular-step-1, tdelta: %.3fms" % (tdelta)
            
        self.broad_phase.step(dt)

        self._collision_pairs = None
        for handler in self.handlers:
            handler(self)
            
    
    @property
    def collision_pairs(self):
        """The set of entity pairs in collision in this timestep"""
        if self._collision_pairs is None:
            cpairs = self.broad_phase.collision_pairs
            t1 = curr_time()
            position = getattr(self.world.components, self.position_component)
            collision = getattr(self.world.components, self.collision_component)
            pairs = self._collision_pairs = set()
            for pair in cpairs:
                entity1, entity2 = pair
                try:
                    position1 = position[entity1].position
                    position2 = position[entity2].position
                    radius1 = collision[entity1].radius
                    radius2 = collision[entity2].radius
                except KeyError:
                    # one of the entities no longer exists.
                    continue
                separation = position2 - position1
                if separation.get_length_sqrd() <= (radius1 + radius2)**2:
                    normal = separation.normalized()
                    pair.set_point_normal(
                        normal * radius1 + position1, normal,
                        normal * -radius2 + position2, -normal)
                    pairs.add(pair)
            
            t2 = curr_time()
            tdelta = t2 - t1
            if tdelta > MIN_TIME_DELTA: 
                print "Collision-circular-pairs, tdelta: %.3fms" % (tdelta)

        return self._collision_pairs
    
    def query_point(self, x_or_point, y=None, from_mask=0xffffffff):
        """Hit test at the point specified. 

        :param x_or_point: x coordinate (float) or sequence of (x, y) floats.

        :param y: y coordinate (float) if x is not a sequence

        :param from_mask: Bit mask used to filter query results. This value
            is bit ANDed with candidate entities' ``collision.into_mask``.
            If the result is non-zero, then it is considered a hit. By
            default all entities colliding with the input point are
            returned.

        :return: A set of entities where the point is inside their collision
            radii as of the last time step.

        """
        if y is None:
            point = Vec2d(x_or_point)
        else:
            point = Vec2d(x_or_point, y)
        hits = set()
        position = getattr(self.world.components, self.position_component)
        collision = getattr(self.world.components, self.collision_component)
        for entity in self.broad_phase.query_point(x_or_point, y, from_mask):
            separation = point - position[entity].position
            if separation.get_length_sqrd() <= collision[entity].radius**2:
                hits.add(entity)
        return hits


def dispatch_events(collision_system):
    """Collision handler that dispatches `on_collide()` events to entities
    marked for collision by the specified collision system. The `on_collide()`
    event handler methods are defined by the application on the desired entity
    classes. These methods should have the following signature::

        def on_collide(self, other_entity, collision_point, collision_normal):
            '''Handle A collision between this entity and `other_entity`

            - other_entity (Entity): The other entity in collision with 
              `self`

            - collision_point (Vec2d): The point on this entity (`self`)
              where the collision occurred. Note this may be `None` for 
              some collision systems that do not report it.

            - collision_normal (Vec2d): The normal vector at the point of
              collision. As with `collision_point`, this may be None for
              some collision systems.
            '''

    Note the arguments to `on_collide()` are always passed positionally, so you
    can use different argument names than above if desired.

    If a pair of entities are in collision, then the event will be dispatched
    to both objects in arbitrary order if all of their collision masks align.
    """
    collision = getattr(collision_system.world.components, 
        collision_system.collision_component)
    cpairs = collision_system.collision_pairs
    t1 = curr_time()
    for pair in cpairs:
        entity1, entity2 = pair
        if pair.info is not None:
            args1, args2 = pair.info
        else:
            args1 = entity1, None, None
            args2 = entity2, None, None
        try:
            on_collide = entity1.on_collide
            masks_align = collision[entity2].from_mask & collision[entity1].into_mask
        except (AttributeError, KeyError):
            pass
        else:
            if masks_align:
                on_collide(*args2)
        try:
            on_collide = entity2.on_collide
            masks_align = collision[entity1].from_mask & collision[entity2].into_mask
        except (AttributeError, KeyError):
            pass
        else:
            if masks_align:
                on_collide(*args1)

    t2 = curr_time()
    tdelta = t2 - t1
    if tdelta > MIN_TIME_DELTA: 
        print "Collision-dispatch-events, tdelta: %.3fms" % (tdelta)
